---
slug: "merge-and-quick-sort"
title: "Merge Sort and Quick Sort"
date: 2020-11-20
author: molson
tags:
  - java
---

In my previous article about sorting algorithms we looked at the basic sorting algorithms in computer science: Selection Sort, Bubble Sort, and Insertion Sort. These
are relatively basic algorithms because they're intuitive, but also because they're not all that efficient. In this post we'll look at the two 
sorting algorithms that are the most often used in software to implement sorting. And why are these the most often used? Because they're fast, with an 
average runtime of O(n*log(n)).

Let's start with my favorite of the two, merge sort. 


## Merge Sort

Think of a list of 1,000,000 items. Then think of a list of 2 items. Which is easier to sort? Well what if we broke that 1,000,000 item list down into 500,000 lists of 2 items. 
Would breaking the list up into sublists help us sort the list faster? 

Merge sort uses this type of divide and conquer strategy. It takes the list and divides it into smaller and smaller lists. It sorts these smaller lists and then 
merges the sorted sublists together. 

Below is a visual of how this works: 

![Merge Sort Gif](https://en.wikipedia.org/wiki/Merge_sort#/media/File:Merge-sort-example-300px.gif)

Notice how you have two distinct steps in this algorithm: 
1. Split lists in half over and over until you're down to list of size 1. 
2. Merge these lists back together, sorting the elements as you merge. 

Take a look at the whole thing in a single picture and see how this process can be represented as a graph or tree: 

![Merge Sort Visual](https://en.wikipedia.org/wiki/Merge_sort#/media/File:Merge_sort_algorithm_diagram.svg)

Hopefully these visuals give you an idea of how this algorithm can be implmented in Java. 

### Implementation

Let's check out the implementation below:

```java
public class Sort {

    public static void main(String[] args) {
        int[] unsorted = { 6, 5, 1, 4, 3 };
        mergeSort(unsorted);
        printArrayOf(unsorted);
    }

    private static int[] mergeSort(int[] arr) {                     
        if (arr.length <= 1) {
            return arr;
        }
        int[] left = mergeSort(split(0, arr.length / 2, arr));
        int[] right = mergeSort(split(arr.length / 2, arr.length, arr));

        return merge(left, right, arr);
    }

    private static int[] split(int start, int end, int[] arr) {
        int[] result = new int[end - start];
        for (int i = start; i < end; i++) { 
            result[i - start] = arr[i];             
        }
        return result;
    }

    private static int[] merge(int[] left, int[] right, int[] arr) {
        int i = 0;
        int j = 0;
        while (i < left.length && j < right.length) {
            if (left[i] < right[j]) {          
                arr[i + j] = left[i]; 
                i++;
            } else {    
                arr[i + j] = right[j]; 
                j++;
            }
        }
        while(i < left.length) {
            arr[i + j] = left[i]; 
            i++;
        }
        while (j < right.length) {
            arr[i + j] = right[j]; 
            j++;
        }
        return arr;
    }

    private static void printArrayOf(int[] arr) {
        for (int value : arr) {
            System.out.print(" " + value + " ");
        }
    }
}

```

![Merge Sort Complexity Explained](https://www.google.com/imgres?imgurl=https%3A%2F%2Fvisualgo.net%2Fimg%2Fmerge.png&imgrefurl=https%3A%2F%2Fvisualgo.net%2Fbn%2Fsorting&tbnid=H9EmxH8oW1UcaM&vet=12ahUKEwiux87W55TtAhUVFjQIHapVDZcQMygAegUIARCoAQ..i&docid=QjJsiwOseP1U6M&w=1022&h=570&q=merge%20sort%20visual&ved=2ahUKEwiux87W55TtAhUVFjQIHapVDZcQMygAegUIARCoAQ)


## Quick Sort

```java
public class Sort {

    public static void main(String[] args) {
        int[] unsorted = { 6, 5, 1, 4, 3 };
        quickSort(unsorted);
        printArrayOf(unsorted);
    }

    public static int[] quickSort(int[] arr) {
        return quickSort(arr, 0, arr.length - 1);
    }

    private static int[] quickSort(int[] arr, int left, int right) {
        if (left < right) {
            int pivotIndex = partition(left, right, arr);

            quickSort(arr, left, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, right);

        }

        return arr;
    }

    private static int partition(int left, int right, int[] arr) {
        Random rand = new Random();
        int pivotIndex = left + (rand.nextInt(right - left + 1));
        int pivot = arr[pivotIndex];
        swap(pivotIndex, right, arr);
        int j = left; 
        for (int i = left; i < right; i++) {
            if (arr[i] <= pivot) { 
                swap(i, j, arr);
                j++;
            }
        }
        swap(j, right, arr);
        return j;
    }

    private static void swap(int i, int j, int[] arr) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    private static void printArrayOf(int[] arr) {
        for (int value : arr) {
            System.out.print(" " + value + " ");
        }
    }

}

```