---
slug: "sorting-algorithms"
title: "Sorting Algorithms - A Review"
date: 2020-10-29
author: molson
tags:
  - java
---

Today we'll review the most common sorting algorithms in computer science. Sorting a list of objects is an extremely
common problem when building data driven applications. We may need to sort a list of phone numbers in numerical order, or
a list of customer names in lexigraphical order. When we have a large scale distributed system, the number of records
that need to be sorted can top 10 million. At that scale, the efficiency of our sorting algorith becomes key. 

We'll take a look at our basic sorting algorithms and try to parse out the runtime efficiency of each. Note that the implementation
of these algorithms will be in Java, but you can implement them in any coding language. 

Before we start, think about this problem: 
- Given a list of unsorted objects, design an algorithm to efficienctly put them into sorted order. 

Now there are a few questions you should think of right off the bat: 
1. What are our objects? Are the letters, numbers, words, things? 

This is a good question because it can dictate your actual sorting mechanism. Letters need to be sorted alphabetically or lexigraphically, 
numbers need to be sorted numerically. If it's a collection of object, you'll need to use an `equals()` method to determine order. 
Whenever you come across a sorting problem, always ask yourself what you are sorting. 

In our case, let's assume they are positive integers. 

2. What is sorted order? Is it ascending or descending? 

Ascending order means that elements to the left are smaller than elements to the right. Another way to say this is as we traverse along 
the list, the elements ascend or get larger. This can be written as follows: ```java 0 <= i <= n - 1; array[i] <= array[i + 1]```

Descending order means that elements to the left are larger than elements to the right. As you traverse along the list, elements will descend in value
or get smalled. This can be wrtten as: ```java 0 <= i <= n - 1; array[i] >= array[i + 1]```

For our problem, let's assume we want the integers sorted into _ascending_ order. 

With these points clarified, how would you go about solving this problem? 

Say your list of integers is ```java [6, 5, 1, 4, 3]```. How would you sort these? 

Let's start with the most basic approach: selection sort. 

## Selection Sort

This algorithm partiitons the input list into two parts. One partition is the already sorted sublist and the second partition is the sublist of remaining elements to be 
sorted. The algorithm will work its way across the list form left to right, finding the smallest element in the list, swapping it with the leftmost unsorted element,
and updating the boundaries of the sublists. It will repeat this iteration until the whole list is sorted. 

![Selection Sort](https://www.codingconnect.net/wp-content/uploads/2016/09/Selection-Sort.gif)

### Implementation

To implement this sorting algorithm, we'll need a few pieces of functionality. 
1. We'll need a method to swap array elements so that we can move the lowest element in the unsorted list to the leftmost index. 

This could be achieved simply: 
```java

public static void swap(int i, int j, int[] arr) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

```
2. We'll need a way to iterate over the array multiple times, while keeping track of the two sub arrays. 

We can use a nested for loop to achieve this. The outer for loop will allow use to iterate over every element in the array while the inner for loop will 
allow us to iterate over all of the so-far unsorted elements. 

3. We'll want to keep track of some sort of running minimum as we're iterating over the unsorted items. 

When all of this comes together our algorithm will look like this: 

```java
public class Sort {

    public static void main(String[] args) {
        int[] unsorted = { 6, 5, 1, 4, 3 };
        selectionSort(unsorted);
        printArrayOf(unsorted);
    }

    public static int[] selectionSort(int[] arr) {
        int stop = arr.length;
        for (int i = 0; i < stop; i++) {
            int min = i;
            for (int j = i + 1; j < stop; j++) {
                if (arr[j] < arr[min]) min = j;
            }
            if (min != i) swap(i, min, arr);
        }
        return arr;
    }

    private static void swap(int i, int j, int[] arr) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

        private static void printArrayOf(int[] arr) {
        for (int value : arr) {
            System.out.print(" " + value + " ");
        }
    }

}

```

The runtime complexity of this sorting algortihm is O(n^2) where n is the size of the list. This is because for every item in the list, we have to visit every item, thus we have to visit n^2 items.
This, unfortunately, is not very efficient. 

## Bubble Sort

Our next most common sorting algorithm is Bubble Sort. Bubble sort compares two adjacent elements and swaps them if they are not in the desired order. It continues until the list is sorted. 
Another way to think about  this is to imagine a sliding window of size 2, moving down the array and comparing the elements in the window. 

Below is a visual representation of bubble sort: 

![Bubble Sort](https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif)

When wathcing this visual, notice how the largest element will get shifted to the rightmost postion for every pass over the array. This is where bubble sort gets its name, as the 
largest elements "bubble up" to the end of the list with each pass. 

### Implementation 

Bubble sort requires looping over the list as well as swapping elements when they are out of order. Thus we'll need our `swap()` method from the Selection Sort implementation and also 
the familiar nested for loops. 

```java
    
 public class Sort {   

    public static void main(String[] args) {
        int[] unsorted = { 6, 5, 1, 4, 3 };
        bubbleSort(unsorted);
        printArrayOf(unsorted);
    }
    
    public static int[] bubbleSort(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length - i; j++) {
                if (arr[j + 1] < arr[j]) swap(j, j+1, arr);
            }
        }
        return arr;
    }

    private static void swap(int i, int j, int[] arr) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    private static void printArrayOf(int[] arr) {
        for (int value : arr) {
            System.out.print(" " + value + " ");
        }
    }
 }
```

Note the bounds of our for loops are different then they were for Selection Sort. The outer for loop runs until the counter reaches `arr.length`, but the nested for loop runs until the counter 
reaches `arr.length - i`. This is due to the nature of the bubble sort algorithm. For each iteration of the outer loop, the largest element in the array is moved to the rightmost index. Thus it
becomes sorted. Our inner loop will not need to check those elements, so we can end our inner loop an `i`th distance from the end of the array. (If this still doesn't make sense, try drawing out the
state of the list at each iteration of the outer for loop and you should see the pattern),

## Insertion Sort

```java
public class Sort {

    public static void main(String[] args) {
        int[] unsorted = { 6, 5, 1, 4, 3 };
        insertionSort(unsorted);
        printArrayOf(unsorted);
    }

    private static int[] insertionSort(int[] arr) {
        int j;
        int element;
        for (int i = 0; i < arr.length; i++) {
            element = arr[i];
            j = i - 1;
            while (j >= 0 && arr[j] > element) {
                arr[i] = arr[j];
                j--;
            }
            arr[j + 1] = element;
        }
        return arr;
    }

    private static void printArrayOf(int[] arr) {
        for (int value : arr) {
            System.out.print(" " + value + " ");
        }
    }

}

```

## Merge Sort


```java
public class Sort {

    public static void main(String[] args) {
        int[] unsorted = { 6, 5, 1, 4, 3 };
        mergeSort(unsorted);
        printArrayOf(unsorted);
    }

    private static int[] mergeSort(int[] arr) {                     
        if (arr.length <= 1) {
            return arr;
        }
        int[] left = mergeSort(split(0, arr.length / 2, arr));
        int[] right = mergeSort(split(arr.length / 2, arr.length, arr));

        return merge(left, right, arr);
    }

    private static int[] split(int start, int end, int[] arr) {
        int[] result = new int[end - start];
        for (int i = start; i < end; i++) { 
            result[i - start] = arr[i];             
        }
        return result;
    }

    private static int[] merge(int[] left, int[] right, int[] arr) {
        int i = 0;
        int j = 0;
        while (i < left.length && j < right.length) {
            if (left[i] < right[j]) {          
                arr[i + j] = left[i]; 
                i++;
            } else {    
                arr[i + j] = right[j]; 
                j++;
            }
        }
        while(i < left.length) {
            arr[i + j] = left[i]; 
            i++;
        }
        while (j < right.length) {
            arr[i + j] = right[j]; 
            j++;
        }
        return arr;
    }

    private static void printArrayOf(int[] arr) {
        for (int value : arr) {
            System.out.print(" " + value + " ");
        }
    }
}

```

## Quick Sort

```java
public class Sort {

    public static void main(String[] args) {
        int[] unsorted = { 6, 5, 1, 4, 3 };
        quickSort(unsorted);
        printArrayOf(unsorted);
    }

    public static int[] quickSort(int[] arr) {
        return quickSort(arr, 0, arr.length - 1);
    }

    private static int[] quickSort(int[] arr, int left, int right) {
        if (left < right) {
            int pivotIndex = partition(left, right, arr);

            quickSort(arr, left, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, right);

        }

        return arr;
    }

    private static int partition(int left, int right, int[] arr) {
        Random rand = new Random();
        int pivotIndex = left + (rand.nextInt(right - left + 1));
        int pivot = arr[pivotIndex];
        swap(pivotIndex, right, arr);
        int j = left; 
        for (int i = left; i < right; i++) {
            if (arr[i] <= pivot) { 
                swap(i, j, arr);
                j++;
            }
        }
        swap(j, right, arr);
        return j;
    }

    private static void swap(int i, int j, int[] arr) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    private static void printArrayOf(int[] arr) {
        for (int value : arr) {
            System.out.print(" " + value + " ");
        }
    }

}

```